##作业:
[作业1](https://github.com/dgb1252/task/blob/master/task_02/%E4%BD%9C%E4%B8%9A1.cpp)    [作业2](https://github.com/dgb1252/task/blob/master/task_02/%E4%BD%9C%E4%B8%9A2.cpp) [作业3](https://github.com/dgb1252/task/blob/master/task_02/%E4%BD%9C%E4%B8%9A3.cpp)  [作业4](https://github.com/dgb1252/task/blob/master/task_02/%E4%BD%9C%E4%B8%9A4.cpp)
#任务心得
1. ~~我觉得合并两个数组排序若要做到空间复杂度为O(1)，那么不可能做到时间复杂度为O(m+n)。(当m和n比较大时/我太菜了。。。)~~ 已解决√
	>用归并，只不过是把元素往大的数组中倒着放
2. 单链表不能像数组那样随机访问,感觉好麻烦,不过一个节点里能保存那么多东西挺好的
3. 创建单链表还是尾插法好用,数据和链表方向是一致的
----
#学习笔记
#<center>时间空间复杂度</center>
####1. 大O时间复杂度表示法: *T(n)=O(f(n))*（时间消耗）
1. __T__ 表示代码执行时间(time),__n__ 表示数据规模的大小，__f(n)__ 表示每行代码的执行的次数总和
2. 对于cpu来说每行代码运行的速率并 __不一定相同__ ，只是计算次数，是表示 __代码执⾏时间随数据规模增⻓的变化趋势__ ，所以也叫 __渐进__ 时间复杂度（asymptotic time complexity）
3. 而 __总复杂度__ 等于 __量级最⼤的那段代代码的复杂度__ 
    - 只关注循环执行次数最多的一段代码(仅限能比较出)
     - 当数据规模n越来越⼤时，__⾮多项式__ __(__ O(2 )和 O(n!)仅有这两个 __)__ 量级算法的执⾏时间会 __急剧增加__
4. 复杂度量级
    1. __O(1)__ :只要算法中不存在循环语句、递归语句，即使有成千上万⾏的代码，其时间复杂度也是Ο(1)。
    2. __O(n$\log_2 n$)、O($\log_2 n$)__ :
        >如：`i=1; while (i <= n)  i = i * 2;`
    3. __O(m+n)、O(m*n)__ :比较不出谁的循环执行次数多就用该量级
#####最好、最坏情况时间复杂度
1. 平均情况时间复杂度 ~~（在与不在是1/2)？？~~ （执行同一种代码但产生的结果不同）
    >~~那不就就等同于4个选项，选对的概率为1/2？？？不应该是1/4吗??(待解决)~~
2. 均摊时间复杂度(在if中？？)
    >~~为啥又不分成1/2了？(待解决)~~
####2. 空间复杂度（内存消耗)

1. 类似为 __渐进__ 空间复杂度（asymptotic space complexity），表示算法的 __存储空间__ 与 __数据规模__ 之间的增⻓关系
---
#<center>排序</center>
### 1. 基于比较的排序算法:  
- BUB - 冒泡排序
- SEL - 选择排序
- INS - 插入排序
- MER - 归并排序 (递归实现)
    >通过比较让小的放入新的数据结构中
    >1. 将每对单个元素（默认情况下，已排序）归并为2个元素的有序数组，
    >2. 将2个元素的每对有序数组归并成4个元素的有序数组，重复这个过程......，
    >3. 最后一步：归并2个N / 2元素的排序数组（假设N是偶数）以获得完全排序的N个元素数组。
- QUI - 快速排序 (递归实现)
    >小的放左边,大的放右边
- R-Q - 随机快速排序 (递归实现)
    >就是随机找个数，与第一个数交换再进行快排
### 2.不基于比较的排序算法:
>因此，任何具有最坏情况复杂度O（n$\log_2 n$）的基于比较的排序算法（如归并排序）都被认为是最优算法
- COU - 计数排序
    >由于内存限制，当 k 相对较大时，我们将无法执行计数排序（Counting Sort）的计数部分，因为我们需要存储那些 k 个整数出现的次数。
- RAD - 基数排序
>把每一个数的同一位数取出来进行计数排序(这时每一个数字所代表的数字不同，即需要把每个数字分别开)
- 反向指针/计数?(待学习)
- 最好的排序整数方法?
#各种排序的复杂度:
|排序方法|时间复杂度(平均)|时间复杂度(最坏)|时间复杂度(最好)|空间复杂度|稳定性|
| ------- | ----- | ----- |   ----- | ----- |  -----|
|插入排序|O(n²)|O(n²)|O(n)|O(1)|  稳定  |
|希尔排序|O($ n^{1.3}$)|O(n²)|O(n)|O(1)|  不稳定  |
|选择排序|O(n²)|O(n²)|O(n²)|O(1)|  不稳定  |
|堆排序|O(n$\log_2 n$)|O(n$\log_2 n$)|O(n$\log_2 n$)|O(1)|  不稳定  |
|冒泡排序|O(n²)|O(n²)|O(n)|O(1)|  稳定  |
|快速排序|O(n$\log_2 n$)|O(n²)|O(n$\log_2 n$)|O(n$\log_2 n$)|  不稳定  |
|归并排序|O(n$\log_2 n$)|O(n$\log_2 n$)|O(n$\log_2 n$)|O(n)|  稳定  |
|计数排序|O(n+k)|O(n+k)|O(n+k)|O(n+k)|  稳定  |
|桶排序|O(n+k)|O(n²)|O(n)|O(n+k)|  稳定  |
|基数排序|O(n*k)|O(n*k)|O(n*k)|O(n+k)|  稳定  |
---
#<center>结构体</center>
1. 结构体中的每个元素也是和数组一样，地址是 __`连续`__ 的
2. 不能将一个结构体对象作为整体输入或输出，__`只能`__ 对结构体对象中的成员 __`逐个`__ 进行输入和输出
3. 结构体可以与结构体之间进行赋值运算， __`不能`__ 进行算术运算
4. 结构体在存储的时候，结构体的首地址`必须`能够被其中`最宽`数据类型`整除`
    >如：`char a;int b;char c;`就会浪费3+3个空间(char为一个字节后面再补充3个)
5. 取结构体对象的地址和数组一致
6. 若未对成员进行初始化，那么自动全为0.这点和数组不同，数组至少要将一个元素进行初始化，才能让其他元素为
7. `typedef int c;     c b等于 int b`
---
#<center>链表</center>
1. 节点可以是结构体也可以是类
2. __`只能`__ 从头到尾访问节点(单链表)
3. ~~我看书上在删除动态内存时都没有删除头节点为什么?~~ 网上查找的有的是删除了头节点的