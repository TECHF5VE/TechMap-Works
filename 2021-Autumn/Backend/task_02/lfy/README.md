# 学习心得
### 一.时间复杂度：
1.  算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好地反映出算法的优劣与否；

2.  算法执行时间需要依据该算法编制的程序在计算机上执行运行时所消耗的时间来度量，度量方法有两种，事后统计方法和事前分析估算方法，因为事后统计方法更多的依赖计算机的硬件，软件等环境因素，有时容易掩盖算法本身的优劣。因此常常采用事前分析估算的方法；

3.  一个算法是由控制结构（顺序，分支，循环三种）和原操作（固有数据类型的操作）构成的，而算法时间取决于两者的综合效率；

4.  一个算法花费的时间与算法中语句的执行次数成正比，执行次数越多，花费的时间就越多。一个算法中的执行次数称为语句频度或时间频度。记为``T（n）``；

5.  在时间频度中，n称为问题的规模，当n不断变化时，它所呈现出来的规律，我们称之为时间复杂度（其实在这中间引入了一个辅助函数``f（n）``，但它与``t（n）``是同数量级函数，我们且先这样理解。）

6.  在各种算法中，若算法中的语句执行次数为一个常数，则时间复杂度为``o（1）``；同时，若不同算法的时间频度不一样，但他们的时间复杂度却可能是一样的，``eg：T(n)=n^2+2n+4``  与 ``T（n）=4n^2+n+8``，他们的时间频度显然不一样，但他们的时间复杂度却是一样的，均为``O(n^2)``，时间复杂度只关注最高数量级，且与之系数也没有关系。

7.   求解算法的时间复杂度的具体步骤是：      
  * ⑴.   找出算法中的基本语句：    
    算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。     
  * ⑵.   计算基本语句的执行次数的数量级：   
　　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。    
  * ⑶.   用大Ο记号表示算法的时间性能：    
　　将基本语句执行次数的数量级放入大Ο记号中。   
　　如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加  
  
### 二.空间复杂度：
1.  空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度；

2.  一个算法在计算机上占用的内存包括：程序代码所占用的空间，输入输出数据所占用的空间，辅助变量所占用的空间这三个方面，程序代码所占用的空间取决于算法本身的长短，输入输出数据所占用的空间取决于要解决的问题，是通过参数表调用函数传递而来，只有辅助变量是算法运行过程中临时占用的存储空间，与空间复杂度相关；

3.  通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为``O(1)``；

4.  对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。
5.  求解算法的时间复杂度:   
    我们在写代码时，完全可以用空间来换取时间，比如字典树，哈希表等都是这个原理。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且「不随问题规模的大小而改变」，我们称这种算法是“就地"进行的，是节省存储的算法，空间复杂度为``O(1)``，注意这并不是说仅仅定义一个临时变量；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将快速排序和归并排序算法就属于这种情况。   
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为`` O(1)``。
### 三.时间复杂度与空间复杂度的关系：
对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。      
当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。      
另外，算法的所有性能之间都存在着或多或少的相互影响。        
因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。       

### 四.问题与笔记:

1.大部分排序算法都学过，基本没遇到什么问题。    
2.在分析希尔排序的时间复杂度时，第一次分析时分析错误。再次认真分析后才分析对。  
3.堆排序类似于插入排序与归并排序结合，拥有两者的优点。  
4.计数排序与桶排序有些相似，但计数排序应用数据较密集时，而桶排序应该是应用于数据较分散时。  
5.不是特别能理解基数排序的原理。  

